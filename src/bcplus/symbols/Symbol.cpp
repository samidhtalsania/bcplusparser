/* Generated by re2c 0.13.5 on Thu Dec 17 18:02:06 2015 */
#line 1 "bcplus/symbols/Symbol.r2c"
#include <string>
#include <ostream>
#include <sstream>

#include "memwrappers.h"

#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp> 
#include <boost/property_tree/exceptions.hpp> 
#include <boost/algorithm/string.hpp>

#include "bcplus/symbols/Symbol.h"

namespace bcplus {
namespace symbols {

char const* Symbol::Type::cstr(type v) {
	switch (v) {
		case SORT:    			 return "sort";
        case CONSTANT: 			 return "constant";
        case VARIABLE:			 return "variable";
        case OBJECT: 			 return "object";
        case MACRO:    			 return "macro";
        case QUERY:    			 return "query";
		case RANGE:              return "range";
		case ERR_INVALID_SYMBOL: return "<invalid>";
		default:				 return "<BAD_SYMBOL_TYPE>";
	}
}

Symbol::Type::type Symbol::Type::val(char const* c) {
	char const* marker;

	
#line 38 "<stdout>"
	{
		char yych;

		yych = *c;
		switch (yych) {
		case '\n':	goto yy2;
		case 'C':
		case 'c':	goto yy5;
		case 'M':
		case 'm':	goto yy8;
		case 'O':
		case 'o':	goto yy7;
		case 'Q':
		case 'q':	goto yy9;
		case 'R':
		case 'r':	goto yy10;
		case 'S':
		case 's':	goto yy3;
		case 'V':
		case 'v':	goto yy6;
		default:	goto yy11;
		}
yy2:
		c = marker;
		goto yy4;
yy3:
		yych = *(marker = ++c);
		switch (yych) {
		case 'O':
		case 'o':	goto yy49;
		default:	goto yy4;
		}
yy4:
#line 48 "bcplus/symbols/Symbol.r2c"
		{ return ERR_INVALID_SYMBOL; }
#line 74 "<stdout>"
yy5:
		yych = *(marker = ++c);
		switch (yych) {
		case 'O':
		case 'o':	goto yy41;
		default:	goto yy4;
		}
yy6:
		yych = *(marker = ++c);
		switch (yych) {
		case 'A':
		case 'a':	goto yy33;
		default:	goto yy4;
		}
yy7:
		yych = *(marker = ++c);
		switch (yych) {
		case 'B':
		case 'b':	goto yy27;
		default:	goto yy4;
		}
yy8:
		yych = *(marker = ++c);
		switch (yych) {
		case 'A':
		case 'a':	goto yy22;
		default:	goto yy4;
		}
yy9:
		yych = *(marker = ++c);
		switch (yych) {
		case 'U':
		case 'u':	goto yy17;
		default:	goto yy4;
		}
yy10:
		yych = *(marker = ++c);
		switch (yych) {
		case 'A':
		case 'a':	goto yy12;
		default:	goto yy4;
		}
yy11:
		yych = *++c;
		goto yy4;
yy12:
		yych = *++c;
		switch (yych) {
		case 'N':
		case 'n':	goto yy13;
		default:	goto yy2;
		}
yy13:
		yych = *++c;
		switch (yych) {
		case 'G':
		case 'g':	goto yy14;
		default:	goto yy2;
		}
yy14:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy15;
		default:	goto yy2;
		}
yy15:
		++c;
#line 47 "bcplus/symbols/Symbol.r2c"
		{ return RANGE; }
#line 145 "<stdout>"
yy17:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy18;
		default:	goto yy2;
		}
yy18:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy19;
		default:	goto yy2;
		}
yy19:
		yych = *++c;
		switch (yych) {
		case 'Y':
		case 'y':	goto yy20;
		default:	goto yy2;
		}
yy20:
		++c;
#line 46 "bcplus/symbols/Symbol.r2c"
		{ return QUERY; }
#line 171 "<stdout>"
yy22:
		yych = *++c;
		switch (yych) {
		case 'C':
		case 'c':	goto yy23;
		default:	goto yy2;
		}
yy23:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy24;
		default:	goto yy2;
		}
yy24:
		yych = *++c;
		switch (yych) {
		case 'O':
		case 'o':	goto yy25;
		default:	goto yy2;
		}
yy25:
		++c;
#line 45 "bcplus/symbols/Symbol.r2c"
		{ return MACRO; }
#line 197 "<stdout>"
yy27:
		yych = *++c;
		switch (yych) {
		case 'J':
		case 'j':	goto yy28;
		default:	goto yy2;
		}
yy28:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy29;
		default:	goto yy2;
		}
yy29:
		yych = *++c;
		switch (yych) {
		case 'C':
		case 'c':	goto yy30;
		default:	goto yy2;
		}
yy30:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy31;
		default:	goto yy2;
		}
yy31:
		++c;
#line 44 "bcplus/symbols/Symbol.r2c"
		{ return OBJECT; }
#line 230 "<stdout>"
yy33:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy34;
		default:	goto yy2;
		}
yy34:
		yych = *++c;
		switch (yych) {
		case 'I':
		case 'i':	goto yy35;
		default:	goto yy2;
		}
yy35:
		yych = *++c;
		switch (yych) {
		case 'A':
		case 'a':	goto yy36;
		default:	goto yy2;
		}
yy36:
		yych = *++c;
		switch (yych) {
		case 'B':
		case 'b':	goto yy37;
		default:	goto yy2;
		}
yy37:
		yych = *++c;
		switch (yych) {
		case 'L':
		case 'l':	goto yy38;
		default:	goto yy2;
		}
yy38:
		yych = *++c;
		switch (yych) {
		case 'E':
		case 'e':	goto yy39;
		default:	goto yy2;
		}
yy39:
		++c;
#line 43 "bcplus/symbols/Symbol.r2c"
		{ return VARIABLE; }
#line 277 "<stdout>"
yy41:
		yych = *++c;
		switch (yych) {
		case 'N':
		case 'n':	goto yy42;
		default:	goto yy2;
		}
yy42:
		yych = *++c;
		switch (yych) {
		case 'S':
		case 's':	goto yy43;
		default:	goto yy2;
		}
yy43:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy44;
		default:	goto yy2;
		}
yy44:
		yych = *++c;
		switch (yych) {
		case 'A':
		case 'a':	goto yy45;
		default:	goto yy2;
		}
yy45:
		yych = *++c;
		switch (yych) {
		case 'N':
		case 'n':	goto yy46;
		default:	goto yy2;
		}
yy46:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy47;
		default:	goto yy2;
		}
yy47:
		++c;
#line 42 "bcplus/symbols/Symbol.r2c"
		{ return CONSTANT; }
#line 324 "<stdout>"
yy49:
		yych = *++c;
		switch (yych) {
		case 'R':
		case 'r':	goto yy50;
		default:	goto yy2;
		}
yy50:
		yych = *++c;
		switch (yych) {
		case 'T':
		case 't':	goto yy51;
		default:	goto yy2;
		}
yy51:
		++c;
#line 41 "bcplus/symbols/Symbol.r2c"
		{ return SORT; }
#line 343 "<stdout>"
	}
#line 49 "bcplus/symbols/Symbol.r2c"

}

std::string Symbol::genName(std::string const& base, size_t arity) {
	return base + "/" + boost::lexical_cast<std::string>(arity);
}


Symbol::Symbol(Type::type type, ReferencedString const* base, size_t arity)
	: _type(type), _arity(arity), _base(base), _good(true) {
	_name = new ReferencedString(genName(*base, arity)); 
	_metadata = NULL;
}

Symbol::Symbol(Type::type type, boost::property_tree::ptree const& node, std::ostream* err) {
	bool good = true;

	try {
		std::string base = node.get("<xmlattr>.base","");
		int arity = node.get("<xmlattr>.arity",0);
	
		if (base == "") {
			good = false;
			if (err) *err << "ERROR: Encountered malformed symbol declaration. Expected a 'base' attribute." << std::endl;
		}

		if (arity < 0) {
			good = false;
			if (err) *err << "ERROR: Encountered malformed symbol declaration. Expected an non-negative integer 'arity' attribute." << std::endl;
		}
	
		_type = type;
		_arity = (size_t)arity;
		_base = new ReferencedString(base);
		
		_name = new ReferencedString(genName(base, arity));
	} catch (boost::property_tree::ptree_error const& e) {
		good = false;
		if (err) *err << "ERROR: Encountered malformed symbol declaration. Expected an non-negative integer 'arity' attribute." << std::endl;
	}


	_good = good;
	_metadata = NULL;
}

Symbol::~Symbol() {
	/* Intentionally left blank */
}

bool Symbol::operator==(Symbol const& other) const {
	if (!good() || !other.good()) return false;
	if (type() != other.type()) return false;
	if (arity() != other.arity()) return false;
	if (*base() != *(other.base())) return false;
	return true;
}

void Symbol::save(boost::property_tree::ptree& node) const {
	node.put("<xmlattr>.base", *base());
	if (arity()) node.put("<xmlattr>.arity", arity());
}


}}
